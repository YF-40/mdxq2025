<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>画像トリミングツール</title>
	<style>
		body {
			font-family: sans-serif;
			padding: 0.5rem;
			background-color: #f5f5f5;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		canvas {
			box-shadow: 0 0 10px rgba(0,0,0,0.2);
			background-color: #eee;
			cursor: grab;
			margin-top: 1rem;
			max-width: 100%;
			width: 320px;
			height: auto;
			touch-action: none;
		}

		.controls {
			margin-top: 1rem;
			display: flex;
			flex-direction: column;
			gap: 1rem;
			align-items: flex-start;
			margin-left: auto;
			margin-right: auto;
		}

		.row {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			flex-wrap: wrap;
		}

		input[type="range"] {
			width: 130px;
		}

		input[type="number"] {
			width: 30px;
		}

		button.decrease, button.increase {
			background-color: rgb(174, 212, 197);
			padding: 0 0.5rem;
			font-size: 0.8rem;
			height: 2rem;
			cursor: pointer;
		}

		#mainarea {
			border-style: solid;
			border-color: #ccc;
			border-radius: 5%;
			padding: 0.5rem;
		}

	</style>
</head>
<body>
	<span id="mainarea">
	<h2 style="margin:0; text-align: center;">画像トリミングツール</h2>

	<input type="file" id="imageInput" accept="image/*">

	<div class="controls">
		<div class="row">
			<label>トリミング形状:
				<select id="shapeSelect">
					<option value="circle">丸</option>
					<option value="rect">四角</option>
				</select>
			</label>
		</div>

		<div class="row" id="sizeRow">
			<label>　サイズ:
				<input type="range" id="sizeRange" min="30" max="1000" value="300">
				<input type="number" id="sizeNumber" min="30" max="1000" value="300">
				<button type="button" class="decrease" data-target="sizeNumber" data-step="10">－</button>
				<button type="button" class="increase" data-target="sizeNumber" data-step="10">＋</button>

			</label>
		</div>

		<div class="row" id="widthRow">
			<label>　　　幅:
				<input type="range" id="rectWidth" min="50" max="1000" value="300">
				<input type="number" id="rectWidthNumber" min="50" max="1000" value="300">
			</label>
		</div>

		<div class="row" id="heightRow">
			<label>　　高さ:
				<input type="range" id="rectHeight" min="50" max="1000" value="300">
				<input type="number" id="rectHeightNumber" min="50" max="1000" value="300">
			</label>
		</div>

		<div class="row">
			<label>枠の太さ:
				<input type="range" id="borderWidth" min="0" max="20" value="4">
				<input type="number" id="borderWidthNumber" min="0" max="20" value="4">
				<button type="button" class="decrease" data-target="borderWidthNumber" data-step="1">－</button>
				<button type="button" class="increase" data-target="borderWidthNumber" data-step="1">＋</button>
			</label>
		</div>

		<div class="row">
			<label>　枠の色:
				<input type="color" id="borderColor" value="#ffffff">
				<input type="text" id="borderColorText" value="#ffffff" style="width:80px;">
			</label>
		</div>

		<div class="row">
			<label>　拡大率:
				<input type="range" id="scaleRange" min="0.1" max="3" step="0.01" value="1">
				<input type="number" id="scaleNumber" min="0.1" max="3" step="0.01" value="1">
				<button type="button" class="decrease" data-target="scaleNumber" data-step="0.1">－</button>
				<button type="button" class="increase" data-target="scaleNumber" data-step="0.1">＋</button>

			</label>
		</div>

		<div class="row">
			<label>保存形式:
				<select id="formatSelect">
					<option value="png">PNG</option>
					<option value="jpeg">JPEG</option>
				</select>
			</label>
			<button id="downloadBtn">画像を保存</button>
		</div>
	</div>

	<canvas id="canvas" style="display:none;"></canvas>
</span>

<script>

// 各HTML要素を取得
const imageInput = document.getElementById('imageInput');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const shapeSelect = document.getElementById('shapeSelect');
const sizeRange = document.getElementById('sizeRange');
const sizeNumber = document.getElementById('sizeNumber');
const rectWidth = document.getElementById('rectWidth');
const rectWidthNumber = document.getElementById('rectWidthNumber');
const rectHeight = document.getElementById('rectHeight');
const rectHeightNumber = document.getElementById('rectHeightNumber');
const borderWidth = document.getElementById('borderWidth');
const borderWidthNumber = document.getElementById('borderWidthNumber');
const borderColor = document.getElementById('borderColor');
const borderColorText = document.getElementById('borderColorText');
const formatSelect = document.getElementById('formatSelect');
const downloadBtn = document.getElementById('downloadBtn');
const scaleRange = document.getElementById('scaleRange');
const scaleNumber = document.getElementById('scaleNumber');

const sizeRow = document.getElementById('sizeRow');
const widthRow = document.getElementById('widthRow');
const heightRow = document.getElementById('heightRow');

// グローバル変数の初期化
let image = new Image();  // アップロードされた画像を保持
let imageLoaded = false;  // 画像が読み込まれたかどうか
let scale = 1;            // 拡大率
let offsetX = 0, offsetY = 0; // 画像の位置のオフセット
let dragging = false;     // ドラッグ中かどうか
let startX, startY;       // ドラッグ開始位置
let originalFileName = 'image'; // 元ファイル名（保存時に使用）

// 画像を読み込んだ時の処理
imageInput.addEventListener('change', function () {
	const file = this.files[0];
	if (!file) return;

	// 拡張子を除いたファイル名を取得
	originalFileName = file.name.split('.').slice(0, -1).join('.') || 'image';

	const reader = new FileReader();
	reader.onload = function (e) {
		image.onload = () => {
			// 画像が読み込まれたときの初期設定
			imageLoaded = true;
			scale = 1;
			scaleRange.value = scaleNumber.value = "1";
			offsetX = 0;
			offsetY = 0;
			canvas.style.display = 'block';

			// 初期サイズ設定（形状に応じて）
			const shape = shapeSelect.value;
			if (shape === "circle") {
				const side = Math.min(image.width, image.height, 400);
				sizeRange.value = sizeNumber.value = side;
			} else {
				rectWidth.value = rectWidthNumber.value = Math.min(image.width, 400);
				rectHeight.value = rectHeightNumber.value = Math.min(image.height, 300);
			}

			draw(); // キャンバスに描画
		};
		image.src = e.target.result;
	};
	reader.readAsDataURL(file); // 画像をBase64に変換して読み込む
});

// キャンバスに画像を描画する関数
function draw() {
	if (!imageLoaded) return;

	const shape = shapeSelect.value;
	const border = parseInt(borderWidth.value);
	let width, height;

	// 形状によってサイズを決定
	if (shape === "circle") {
		width = height = parseInt(sizeRange.value);
	} else {
		width = parseInt(rectWidth.value);
		height = parseInt(rectHeight.value);
	}

	canvas.width = width;
	canvas.height = height;
	ctx.clearRect(0, 0, width, height); // キャンバスをクリア

	ctx.save();
	if (shape === "circle") {
		// 丸くクリップする（切り抜き）
		ctx.beginPath();
		ctx.arc(width / 2, height / 2, width / 2 - border, 0, Math.PI * 2);
		ctx.closePath();
		ctx.clip();
	}

	// 拡大率に応じた画像サイズを計算し、中央に配置
	const imgW = image.width * scale;
	const imgH = image.height * scale;
	const x = width / 2 - imgW / 2 + offsetX;
	const y = height / 2 - imgH / 2 + offsetY;
	ctx.drawImage(image, x, y, imgW, imgH);
	ctx.restore();

	// 枠線を描画
	ctx.beginPath();
	if (shape === "circle") {
		ctx.arc(width / 2, height / 2, width / 2 - border / 2, 0, Math.PI * 2);
	} else {
		const pad = border / 2;
		ctx.rect(pad, pad, width - pad * 2, height - pad * 2);
	}
	ctx.strokeStyle = borderColor.value;
	ctx.lineWidth = border;
	ctx.stroke();
}

// スライダーと数値入力を同期させる関数
function bindSliderAndNumber(rangeEl, numberEl, callback) {
	rangeEl.addEventListener('input', () => {
		numberEl.value = rangeEl.value;
		callback();
	});
	numberEl.addEventListener('input', () => {
		rangeEl.value = numberEl.value;
		callback();
	});
}

// 各コントロールと描画関数をバインド
bindSliderAndNumber(sizeRange, sizeNumber, draw);
bindSliderAndNumber(borderWidth, borderWidthNumber, draw);
bindSliderAndNumber(rectWidth, rectWidthNumber, draw);
bindSliderAndNumber(rectHeight, rectHeightNumber, draw);
bindSliderAndNumber(scaleRange, scaleNumber, () => {
	scale = parseFloat(scaleRange.value);
	draw();
});

// 色の同期
borderColor.addEventListener('input', () => {
	borderColorText.value = borderColor.value;
	draw();
});
borderColorText.addEventListener('input', () => {
	const val = borderColorText.value.trim();
	const temp = document.createElement('div');
	temp.style.color = '';
	temp.style.color = val;
	if (temp.style.color !== '') {
		borderColor.value = val;
		draw();
	}
});

// トリミング形状変更時にUIを切り替える
shapeSelect.addEventListener('input', () => {
	const shape = shapeSelect.value;
	sizeRow.style.display = shape === 'circle' ? 'flex' : 'none';
	widthRow.style.display = shape === 'rect' ? 'flex' : 'none';
	heightRow.style.display = shape === 'rect' ? 'flex' : 'none';
	draw();
});

// ドラッグ処理（マウス）
canvas.addEventListener('mousedown', (e) => {
	dragging = true;
	startX = e.offsetX;
	startY = e.offsetY;
	canvas.style.cursor = 'grabbing';
});
canvas.addEventListener('mouseup', () => { dragging = false; canvas.style.cursor = 'grab'; });
canvas.addEventListener('mouseleave', () => { dragging = false; canvas.style.cursor = 'grab'; });
canvas.addEventListener('mousemove', (e) => {
	if (dragging && imageLoaded) {
		offsetX += e.offsetX - startX;
		offsetY += e.offsetY - startY;
		startX = e.offsetX;
		startY = e.offsetY;
		draw();
	}
});

// タッチ処理（開始）
canvas.addEventListener('touchstart', (e) => {
	const touch = e.touches[0];
	const rect = canvas.getBoundingClientRect();
	startX = touch.clientX - rect.left;
	startY = touch.clientY - rect.top;
	dragging = true;
});

// ピンチイン・ピンチアウト（2本指で拡大縮小）
let lastTouchDistance = null;

function getTouchDistance(touches) {
	if (touches.length < 2) return null;
	const dx = touches[0].clientX - touches[1].clientX;
	const dy = touches[0].clientY - touches[1].clientY;
	return Math.hypot(dx, dy);
}

canvas.addEventListener('touchstart', (e) => {
	if (e.touches.length === 2) {
		lastTouchDistance = getTouchDistance(e.touches);
	}
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
	if (e.touches.length === 2 && imageLoaded) {
		e.preventDefault();
		const newDistance = getTouchDistance(e.touches);
		if (lastTouchDistance && newDistance) {
			const delta = newDistance / lastTouchDistance;
			scale *= delta;
			scale = Math.min(Math.max(scale, 0.1), 3);
			scaleRange.value = scaleNumber.value = scale.toFixed(2);
			draw();
			lastTouchDistance = newDistance;
		}
	}
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
	if (e.touches.length < 2) {
		lastTouchDistance = null;
	}
});

// 指でのドラッグ処理
canvas.addEventListener('touchmove', (e) => {
	if (!dragging || !imageLoaded) return;
	e.preventDefault();
	const touch = e.touches[0];
	const rect = canvas.getBoundingClientRect();
	const moveX = touch.clientX - rect.left;
	const moveY = touch.clientY - rect.top;
	offsetX += moveX - startX;
	offsetY += moveY - startY;
	startX = moveX;
	startY = moveY;
	draw();
}, { passive: false });

canvas.addEventListener('touchend', () => { dragging = false; });

// ホイールによる拡大縮小
canvas.addEventListener('wheel', (e) => {
	if (!imageLoaded) return;
	e.preventDefault();
	const scaleAmount = e.deltaY > 0 ? 0.95 : 1.05;
	scale *= scaleAmount;
	scale = Math.min(Math.max(scale, 0.1), 3);
	scaleRange.value = scaleNumber.value = scale.toFixed(2);
	draw();
});

// 「画像を保存」ボタンクリック時の処理
downloadBtn.addEventListener('click', () => {
	const format = formatSelect.value;
	const link = document.createElement('a');
	link.download = `${originalFileName}_trim.${format}`;

	// JPEG形式は白背景にする必要あり
	if (format === 'jpeg') {
		const tempCanvas = document.createElement('canvas');
		tempCanvas.width = canvas.width;
		tempCanvas.height = canvas.height;
		const tempCtx = tempCanvas.getContext('2d');
		tempCtx.fillStyle = '#fff';
		tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
		tempCtx.drawImage(canvas, 0, 0);
		link.href = tempCanvas.toDataURL('image/jpeg');
	} else {
		link.href = canvas.toDataURL('image/png');
	}
	link.click(); // 自動ダウンロード
});

// 初期状態で形状のUI切り替えを実行
shapeSelect.dispatchEvent(new Event('input'));

// ＋／－ボタンのクリックで数値入力を増減
document.querySelectorAll('button.increase, button.decrease').forEach(btn => {
	btn.addEventListener('click', () => {
		const targetId = btn.dataset.target;
		const input = document.getElementById(targetId);
		const step = parseFloat(btn.dataset.step);
		const isIncrease = btn.classList.contains('increase');
		let value = parseFloat(input.value);
		if (isNaN(value)) value = 0;
		value += isIncrease ? step : -step;

		// 最小・最大値の範囲内に調整
		const min = parseFloat(input.min);
		const max = parseFloat(input.max);
		if (!isNaN(min)) value = Math.max(value, min);
		if (!isNaN(max)) value = Math.min(value, max);

		input.value = value.toFixed(2); // 小数点にも対応
		input.dispatchEvent(new Event('input')); // 値を同期させる
	});
});

</script>

</body>
</html>
