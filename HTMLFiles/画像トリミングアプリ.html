<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>画像トリミングアプリ</title>
	<style>
		body {
			font-family: sans-serif;
			padding: 1rem;
			background-color: #f5f5f5;
			display: flex;
			flex-direction: column;
			align-items: center;
		}

		canvas {
			box-shadow: 0 0 10px rgba(0,0,0,0.2);
			background-color: #eee;
			cursor: grab;
			margin-top: 1rem;
			width: 100%;
			height: auto;
			touch-action: none;
		}

		.controls {
			margin-top: 1rem;
			display: flex;
			flex-direction: column;
			gap: 1rem;
			align-items: flex-start;
			margin-left: auto;
			margin-right: auto;
		}

		.row {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			flex-wrap: wrap;
		}

		input[type="range"] {
			width: 150px;
		}

		input[type="number"] {
			width: 60px;
		}
	</style>
</head>
<body>
	<h1>画像トリミングアプリ</h1>

	<input type="file" id="imageInput" accept="image/*">

	<div class="controls">
		<div class="row">
			<label>トリミング形状:
				<select id="shapeSelect">
					<option value="circle">丸</option>
					<option value="rect">四角</option>
				</select>
			</label>
		</div>

		<div class="row" id="sizeRow">
			<label>　サイズ:
				<input type="range" id="sizeRange" min="50" max="1000" value="300">
				<input type="number" id="sizeNumber" min="50" max="1000" value="300">
			</label>
		</div>

		<div class="row" id="widthRow">
			<label>　　　幅:
				<input type="range" id="rectWidth" min="50" max="1000" value="300">
				<input type="number" id="rectWidthNumber" min="50" max="1000" value="300">
			</label>
		</div>

		<div class="row" id="heightRow">
			<label>　　高さ:
				<input type="range" id="rectHeight" min="50" max="1000" value="300">
				<input type="number" id="rectHeightNumber" min="50" max="1000" value="300">
			</label>
		</div>

		<div class="row">
			<label>枠の太さ:
				<input type="range" id="borderWidth" min="0" max="20" value="4">
				<input type="number" id="borderWidthNumber" min="0" max="20" value="4">
			</label>
		</div>

		<div class="row">
			<label>　枠の色:
				<input type="color" id="borderColor" value="#ffffff">
				<input type="text" id="borderColorText" value="#ffffff" style="width:80px;">
			</label>
		</div>

		<div class="row">
			<label>　拡大率:
				<input type="range" id="scaleRange" min="0.1" max="3" step="0.01" value="1">
				<input type="number" id="scaleNumber" min="0.1" max="3" step="0.01" value="1">
			</label>
		</div>

		<div class="row">
			<label>保存形式:
				<select id="formatSelect">
					<option value="png">PNG</option>
					<option value="jpeg">JPEG</option>
				</select>
			</label>
			<button id="downloadBtn">画像を保存</button>
		</div>
	</div>

	<canvas id="canvas" style="display:none;"></canvas>

<script>
	const imageInput = document.getElementById('imageInput');
	const canvas = document.getElementById('canvas');
	const ctx = canvas.getContext('2d');

	const shapeSelect = document.getElementById('shapeSelect');
	const sizeRange = document.getElementById('sizeRange');
	const sizeNumber = document.getElementById('sizeNumber');
	const rectWidth = document.getElementById('rectWidth');
	const rectWidthNumber = document.getElementById('rectWidthNumber');
	const rectHeight = document.getElementById('rectHeight');
	const rectHeightNumber = document.getElementById('rectHeightNumber');
	const borderWidth = document.getElementById('borderWidth');
	const borderWidthNumber = document.getElementById('borderWidthNumber');
	const borderColor = document.getElementById('borderColor');
	const borderColorText = document.getElementById('borderColorText');
	const formatSelect = document.getElementById('formatSelect');
	const downloadBtn = document.getElementById('downloadBtn');
	const scaleRange = document.getElementById('scaleRange');
	const scaleNumber = document.getElementById('scaleNumber');

	const sizeRow = document.getElementById('sizeRow');
	const widthRow = document.getElementById('widthRow');
	const heightRow = document.getElementById('heightRow');

	let image = new Image();
	let imageLoaded = false;
	let scale = 1;
	let offsetX = 0, offsetY = 0;
	let dragging = false;
	let startX, startY;
	let originalFileName = 'image';

	imageInput.addEventListener('change', function () {
		const file = this.files[0];
		if (!file) return;
		originalFileName = file.name.split('.').slice(0, -1).join('.') || 'image';

		const reader = new FileReader();
		reader.onload = function (e) {
			image.onload = () => {
				imageLoaded = true;
				scale = 1;
				scaleRange.value = scaleNumber.value = "1";
				offsetX = 0;
				offsetY = 0;
				canvas.style.display = 'block';

				const shape = shapeSelect.value;
				if (shape === "circle") {
					const side = Math.min(image.width, image.height, 400);
					sizeRange.value = sizeNumber.value = side;
				} else {
					rectWidth.value = rectWidthNumber.value = Math.min(image.width, 400);
					rectHeight.value = rectHeightNumber.value = Math.min(image.height, 300);
				}

				draw();
			};
			image.src = e.target.result;
		};
		reader.readAsDataURL(file);
	});

	function draw() {
		if (!imageLoaded) return;

		const shape = shapeSelect.value;
		const border = parseInt(borderWidth.value);
		let width, height;

		if (shape === "circle") {
			width = height = parseInt(sizeRange.value);
		} else {
			width = parseInt(rectWidth.value);
			height = parseInt(rectHeight.value);
		}

		canvas.width = width;
		canvas.height = height;
		ctx.clearRect(0, 0, width, height);

		ctx.save();
		if (shape === "circle") {
			ctx.beginPath();
			ctx.arc(width / 2, height / 2, width / 2 - border, 0, Math.PI * 2);
			ctx.closePath();
			ctx.clip();
		}

		const imgW = image.width * scale;
		const imgH = image.height * scale;
		const x = width / 2 - imgW / 2 + offsetX;
		const y = height / 2 - imgH / 2 + offsetY;
		ctx.drawImage(image, x, y, imgW, imgH);
		ctx.restore();

		ctx.beginPath();
		if (shape === "circle") {
			ctx.arc(width / 2, height / 2, width / 2 - border / 2, 0, Math.PI * 2);
		} else {
			const pad = border / 2;
			ctx.rect(pad, pad, width - pad * 2, height - pad * 2);
		}
		ctx.strokeStyle = borderColor.value;
		ctx.lineWidth = border;
		ctx.stroke();
	}

	function bindSliderAndNumber(rangeEl, numberEl, callback) {
		rangeEl.addEventListener('input', () => {
			numberEl.value = rangeEl.value;
			callback();
		});
		numberEl.addEventListener('input', () => {
			rangeEl.value = numberEl.value;
			callback();
		});
	}

	bindSliderAndNumber(sizeRange, sizeNumber, draw);
	bindSliderAndNumber(borderWidth, borderWidthNumber, draw);
	bindSliderAndNumber(rectWidth, rectWidthNumber, draw);
	bindSliderAndNumber(rectHeight, rectHeightNumber, draw);
	bindSliderAndNumber(scaleRange, scaleNumber, () => {
		scale = parseFloat(scaleRange.value);
		draw();
	});

	borderColor.addEventListener('input', () => {
		borderColorText.value = borderColor.value;
		draw();
	});
	borderColorText.addEventListener('input', () => {
		const val = borderColorText.value.trim();
		const temp = document.createElement('div');
		temp.style.color = '';
		temp.style.color = val;
		if (temp.style.color !== '') {
			borderColor.value = val;
			draw();
		}
	});

	shapeSelect.addEventListener('input', () => {
		const shape = shapeSelect.value;
		sizeRow.style.display = shape === 'circle' ? 'flex' : 'none';
		widthRow.style.display = shape === 'rect' ? 'flex' : 'none';
		heightRow.style.display = shape === 'rect' ? 'flex' : 'none';
		draw();
	});

	canvas.addEventListener('mousedown', (e) => {
		dragging = true;
		startX = e.offsetX;
		startY = e.offsetY;
		canvas.style.cursor = 'grabbing';
	});
	canvas.addEventListener('mouseup', () => { dragging = false; canvas.style.cursor = 'grab'; });
	canvas.addEventListener('mouseleave', () => { dragging = false; canvas.style.cursor = 'grab'; });
	canvas.addEventListener('mousemove', (e) => {
		if (dragging && imageLoaded) {
			offsetX += e.offsetX - startX;
			offsetY += e.offsetY - startY;
			startX = e.offsetX;
			startY = e.offsetY;
			draw();
		}
	});

	canvas.addEventListener('touchstart', (e) => {
		const touch = e.touches[0];
		const rect = canvas.getBoundingClientRect();
		startX = touch.clientX - rect.left;
		startY = touch.clientY - rect.top;
		dragging = true;
	});
	canvas.addEventListener('touchmove', (e) => {
		if (!dragging || !imageLoaded) return;
		e.preventDefault();
		const touch = e.touches[0];
		const rect = canvas.getBoundingClientRect();
		const moveX = touch.clientX - rect.left;
		const moveY = touch.clientY - rect.top;
		offsetX += moveX - startX;
		offsetY += moveY - startY;
		startX = moveX;
		startY = moveY;
		draw();
	}, { passive: false });
	canvas.addEventListener('touchend', () => { dragging = false; });

	canvas.addEventListener('wheel', (e) => {
		if (!imageLoaded) return;
		e.preventDefault();
		const scaleAmount = e.deltaY > 0 ? 0.95 : 1.05;
		scale *= scaleAmount;
		scale = Math.min(Math.max(scale, 0.1), 3);
		scaleRange.value = scaleNumber.value = scale.toFixed(2);
		draw();
	});

	downloadBtn.addEventListener('click', () => {
		const format = formatSelect.value;
		const link = document.createElement('a');
		link.download = `${originalFileName}_trim.${format}`;

		if (format === 'jpeg') {
			const tempCanvas = document.createElement('canvas');
			tempCanvas.width = canvas.width;
			tempCanvas.height = canvas.height;
			const tempCtx = tempCanvas.getContext('2d');
			tempCtx.fillStyle = '#fff';
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
			tempCtx.drawImage(canvas, 0, 0);
			link.href = tempCanvas.toDataURL('image/jpeg');
		} else {
			link.href = canvas.toDataURL('image/png');
		}
		link.click();
	});

	shapeSelect.dispatchEvent(new Event('input'));
</script>

</body>
</html>
